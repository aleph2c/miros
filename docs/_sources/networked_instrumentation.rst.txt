.. _networked_instrumentation-spy-and-trace-across-a-network:

Spy and Trace Across a Network
==============================

.. _networked_instrumentation-context:

Context
-------


The spy and trace tools are extremely useful for designing, debugging, testing
and documenting the behavior of your statecharts.

But how would you view the spy and trace information from different statecharts,
running on different computers, across a network?

It would be useful if you could send the spy and trace information from one
machine to another and aggregate it in one location.  Aggregating all of the spy
and trace information onto one machine will make it look like all of your
statecharts are just running in different threads, on that machine, instead of on different
computers.  We already know how to make sense of statecharts running in different
threads.  So if we use such an aggregation technique, we could understand how
different statecharts running on different machines are working together.

In this example I will run a statechart on one computer, then view it's
spy and trace log on another.

.. _networked_instrumentation-getting-the-required-libraries:

Getting the Required Libraries
------------------------------

Up until now I have only been using ``miros`` and the Python standard library.
To make this example work, you will have to install ``pika`` for messaging with
RabbitMq and ``cryptography`` for encrypting your messages.  So let's do that
now:

.. code-block:: python

  > pip3 install pika cryptography --user


.. _networked_instrumentation-setting-up-and-network-and-messaging:

Setting Up and Network and Messaging
------------------------------------
This example is going to use RabbitMq for messaging.  This is an extremely
powerful messaging platform, but to use it you must first set it up on all of
your computers.  I have written how to do that
:ref:`here<setting_up_rabbit_mq-setting-up-rabbit-mq>`.

When I constructed this example I placed a statechart on a raspberry pi, running
Linux and had it send messages to a program running on a Windows 10 machine.  To
use the RabbitMq terminology the program running on my raspberry pi was a
producer, because it is producing information.  The spy and trace aggregator
running on Windows was the consumer, since it consumes the messages generated
elsewhere.

In order to keep things as simple as possible, I wrote a ForeignHsm class which
can accept spy and trace logs.  To access these logs you would use its ``spy``
and ``trace`` methods, just like you would with any other statechart.  So the
ForeignHsm object will live on the consumer, since it will consume the spy and
trace logs being generated by the statechart running on the raspberry pi.

RabbitMq has a variety of different messaging routing techniques.  Our
aggregation consumer will want to receive all messages from the foreign
statechart.  If I decided to run this consumer in two different threads in
Windows, I would want each of them to see all of the messages generated by the
raspberry pi.  For this reason, I used the ``fanout`` routing technique offered
by RabbitMq.  This ``fanout`` technique ensures that any message generated by a
producer is seen by every connected consumer.

.. _networked_instrumentation-example-design-specification:

Example Design Specification
----------------------------

To begin the example I will write a specification:

* A statechart on one machine should have it's spy and trace output on another
* All messages should be encrypted while on the network
* A producer can be run multiple times in unison.  If this happens all
  connected consumers should receive all spy and trace information being
  generated by each producer.
* A consumer should be able to be run multiple times in unison.  If this
  happens, each consumer should receive all messages being generated by each
  producer in the network.

.. note::

  If you would like to skip the explanations and just look at the code, it's here:

  .. include:: i_networking_instrumentation_file_table.rst


Now let's try to build something that meets our design goals.

.. _networked_instrumentation-the-producer-design:

The Producer Design
-------------------

I'll start with the producer's code, let's call it `c_trace_producer`_ to show
that it is based on the `3rd (c) example
<https://www.rabbitmq.com/tutorials/tutorial-three-python.html>`_ provided by
the rabbitmq team.  If you haven't gone through these tutorials, here is a link
to the referenced tutorial and a link to my own code that extends it so that it
works over a network:

===================  ======================= ===================================
Tutorial Purpose     RabbitMQ Pika Tutorial  Networked Version of their Tutorial
===================  ======================= ===================================
- Publish/Subscribe   `simple pub-sub`_      - `networked pub-sub send`_
                                             - `networked pub-sub receive`_
===================  ======================= ===================================

If you are feeling comfortable enough with programming RabbitMq with ``pika``
then let us move on and design the producer:

.. _producer_design:

.. image:: _static/rabbit_chart_producer_1.svg
    :align: center

Above we see the UML diagram for the RabbitProducer.  It is mostly just a
Factory with some additional attributes to track a rabbitMq connection.

This RabbitProducer class can be found in the `c_trace_producer`_ file.  It
contains all of the statechart features that a Factory class has and the
additional capability of sending messages across a network.

The RabbitMq messaging strategy is drawn into the diagram as the coloured part.
It will consist of a spy and a trace producer, each transmitting messages into
their own exchanges, which will in turn spit their messages onto the network.

The information that feeds these producers will come from the spy and trace
logs being generated by the statechart as it reacts to events.  We will start
the chart, then send a B signal to it, then turn off the connection.

If we ever intend on building a producer with this technology we will have to
hide its messages while they are on the big-bad-internet.  For this reason the
example will also demonstrate a very simple form of encryption.

Now that we have a design, we will begin to build it by:

1. :ref:`making a class that can send information on the network<networked_instrumentation-making-a-class-that-can-send-information-on-the-network>`
2. :ref:`connecting the output of our spy and trace logs to the network<networked_instrumentation-connect-the-output-of-our-spy-and-trace-logs-to-the-network>`
3. :ref:`creating the statechart's HSM<networked_instrumentation-create-the-statecharts-hsm>`
4. :ref:`making our statechart react to some events<networked_instrumentation-have-our-statechart-reat-to-some-events>`
5. :ref:`closing the connection<networked_instrumentation-close-the-connection>`

.. _networked_instrumentation-making-a-class-that-can-send-information-on-the-network:

Making a Class that can Send Information on the Network
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. _networked_instrumentation-subsubsection_titl:

Let's begin framing in the RabbitProducer class:

.. code-block:: python
  :emphasize-lines: 3, 14, 15
  :linenos:

  class RabbitProducer(Factory):
    def __init__(self, chart_name, rabbit_user, rabbit_password, ip, port):
      super().__init__(chart_name + '_' + ip)
      self.rabbit_user = rabbit_user
      self.rabbit_password = rabbit_password
      self.destination_ip = ip
      self.destination_port = port

      credentials = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters = pika.ConnectionParameters(ip, port, '/', credentials)
      self.connection = pika.BlockingConnection(parameters=parameters)

      self.channel = self.connection.channel()
      self.channel.exchange_declare(exchange='spy', exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

Line 3 shows where we append the consumer's ip address to the statechart name.

The rest of the code is basically boiler plate rabbitMq code with the exception
of line 14 and 15.  Here we see that we are declaring two separate exchanges,
both using the `fanout` routing strategy.

The `fanout` strategy will ensure that any consumer which is subscribing to one
of these exchanges will get all of the messages being sent from them.

.. _networked_instrumentation-connect-the-output-of-our-spy-and-trace-logs-to-the-network:

Connect the output of our Spy and Trace Logs to the Network
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now that we have something that can send messages over a network let's wire it
up to the logs being emitted by our statechart:

.. code-block:: python
  :emphasize-lines: 17-23, 25-33, 35-41, 43-50, 52-55
  :linenos:
  
  class RabbitProducer(Factory):
    def __init__(self, chart_name, rabbit_user, rabbit_password, ip, port):
      super().__init__(chart_name + '_' + ip)
      self.rabbit_user = rabbit_user
      self.rabbit_password = rabbit_password
      self.destination_ip = ip
      self.destination_port = port

      credentials = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters = pika.ConnectionParameters(ip, port, '/', credentials)
      self.connection = pika.BlockingConnection(parameters=parameters)

      self.channel = self.connection.channel()
      self.channel.exchange_declare(exchange='spy', exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      def strip_trace(fn):
        @wraps(fn)
        def _strip_trace(trace_live):
          trace_live = trace_live.replace("\n", "")
          # encrypt
          fn(trace_live)
        return _strip_trace

      def encrypt(fn):
        @wraps(fn)
        def _encrypt(plain_text):
          key = b'u3Uc-qAi9iiCv3fkBfRUAKrM1gH8w51-nVU8M8A73Jg='
          f = Fernet(key)
          cyphertext = f.encrypt(plain_text.encode())
          # broadcast_trace/broadcast_spy
          fn(cyphertext)
        return _encrypt

      @encrypt
      def broadcast_spy(spy_live):
        self.channel.basic_publish(
            exchange='spy',
            routing_key='',
            body=spy_live
        )

      @strip_trace
      @encrypt
      def broadcast_trace(trace_live):
        self.channel.basic_publish(
            exchange='trace',
            routing_key='',
            body=trace_live
        )

      self.register_live_spy_callback(broadcast_spy)
      self.register_live_trace_callback(broadcast_trace)
      self.live_spy   = True
      self.live_trace = True

The newly added code is highlighted.

I'm going to ask you to look at the new code out of sequence.  Let's begin with
lines 54 and 55.  Here we see we are turning on the live spy and trace logging
for the statechart.

On lines 52 and 53 we are calling the ``register_live_spy_callback`` and
``register_live_trace_callback`` to allow us to over-write the live spy and trace
behavior.  Instead of just outputting information to a terminal, we send
information into the provided functions.  So for instance, anytime our
statechart emits an item to it's spy instrumentation it will send this to the
``broadcast_spy`` function instead. 

The ``broadcast_spy`` function is defined within the ``__init__`` method scope
to enclose the ``self.channel`` object.  I wrote it this way, because the
callback signature only has one argument, the ``spy_live`` argument.  It doesn't
accept ``self`` and I need access to the ``self`` attribute to gain access to
the network.  I'm sure there is a cool way to get around this limitation, but I
didn't think about it too hard since I knew I could solve my issue with a
closure.

Both the ``broadcast_spy`` and ``broadcast_trace`` callback functions can send
strings across the network.  We see these functions are both decorated with
``encrypt``.  This means that before they do their business their input is sent
to the ``encrypt`` function defined on line 27.

.. note::
  There are two main encryption libraries for Python, one is ``cryptography``
  and the other is ``pycrypto``.  Use ``cryptography`` since ``pycrypto`` will
  crash on windows.

Take note of the key, the consumer will have to have the same key or it will
not be able to make sense of the messages sent to it.

The code is cluttered a bit with the ``strip_trace`` decorator, which removes
the newline characters for the trace stream.  I left it in the example because
you might want to follow this pattern for sprucing up your messages prior to
sending them out over the network.

.. _networked_instrumentation-create-the-statecharts-hsm:

Create the Statechart's HSM
^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now create a RabbitProducer chart and add a hierarchical state machine to it.
The newly added code is highlighted:

.. code-block:: python
  :emphasize-lines: 58-67, 70-72, 75-77, 80-82, 85-91, 93-96, 98-100, 102-104, 106-108
  :linenos:

  class RabbitProducer(Factory):
    def __init__(self, chart_name, rabbit_user, rabbit_password, ip, port):
      super().__init__(chart_name + '_' + ip)
      self.rabbit_user = rabbit_user
      self.rabbit_password = rabbit_password
      self.destination_ip = ip
      self.destination_port = port

      credentials = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters = pika.ConnectionParameters(ip, port, '/', credentials)
      self.connection = pika.BlockingConnection(parameters=parameters)

      self.channel = self.connection.channel()
      self.channel.exchange_declare(exchange='spy', exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      def strip_trace(fn):
        @wraps(fn)
        def _strip_trace(trace_live):
          trace_live = trace_live.replace("\n", "")
          # broadcast_trace
          fn(trace_live)
        return _strip_trace

      def encrypt(fn):
        @wraps(fn)
        def _encrypt(plain_text):
          key = b'u3Uc-qAi9iiCv3fkBfRUAKrM1gH8w51-nVU8M8A73Jg='
          f = Fernet(key)
          cyphertext = f.encrypt(plain_text.encode())
          # broadcast_trace/broadcast_spy
          fn(cyphertext)
        return _encrypt

      @encrypt
      def broadcast_spy(spy_live):
        self.channel.basic_publish(
            exchange='spy',
            routing_key='',
            body=spy_live
        )

      @strip_trace
      @encrypt
      def broadcast_trace(trace_live):
        self.channel.basic_publish(
            exchange='trace',
            routing_key='',
            body=trace_live
        )

      self.register_live_spy_callback(broadcast_spy)
      self.register_live_trace_callback(broadcast_trace)
      self.live_spy   = True
      self.live_trace = True


  #  +-------- producer_outer ---------+
  #  |   +--- c1 ----+   +---- c2 ---+ |
  #  | * |           |   |           | +--+
  #  | | |           +-A->           | |  |
  #  | +->           <-A-+           | |  B
  #  |   |           |   |           | <--+
  #  |   +-----------+   +-----------+ |
  #  +---------------------------------+
  def producer_outer_init(chart, e):
    return chart.trans(c1)


  def producer_outer_B(chart, e):
    status = chart.trans(producer_outer)
    return status


  def c1_A(chart, e):
    status = chart.trans(c2)
    return status


  def c2_A(chart, e):
    status = chart.trans(c1)
    return status


  chart = RabbitProducer(
    chart_name="producer",
    rabbit_user="bob",
    rabbit_password="dobbs",
    ip="192.168.1.72",
    port=5672
  )

  producer_outer = chart.create(state='producer_outer'). \
    catch(signal=signals.INIT_SIGNAL, handler=producer_outer_init). \
    catch(signal=signals.B, handler=producer_outer_B). \
    to_method()

  c1 = chart.create(state='c1'). \
    catch(signal=signals.A, handler=c1_A). \
    to_method()

  c2 = chart.create(state='c2'). \
    catch(signal=signals.A, handler=c2_A). \
    to_method()

  chart.nest(producer_outer, parent=None). \
    nest(c1, parent=producer_outer). \
    nest(c2, parent=producer_outer)

On lines 58-65 we see an ascii-art version of the statechart we are trying to
build.  On lines 70 through 82 we see the state method callbacks which will be used to
provide their arrows on the diagram.

On lines 85-91, we see that we are constructing a chart which will emit logs to
a foreign consumer.  In constructing this object we provide the credentials
required to dispatch from the local rabbitmq server.

On lines 93-104 we create the state methods, linking callbacks to specific
signal names.

Finally, on lines 106 to 108 we add the chart's hierarchy, using the ``nest``
method.

.. _networked_instrumentation-have-our-statechart-reat-to-some-events:

Have our statechart React to some Events
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The full RabbitMq chart has been built and linked to its own thread with access
to a rabbitMq server and thereby access to the whole internet.

Now it is time to start our chart and watch it change it's state.  We will start
it in the producer_outer state, wait, then send a ``B`` signal at it.

.. code-block:: python
  :emphasize-lines: 2-6
  :linenos:
  
  # RabbitMq chart construction above 
  chart.start_at(producer_outer)
  chart.post_fifo(Event(signal=signals.B))
  time.sleep(0.1)
  pp(chart.spy())
  print(chart.trace())

.. _networked_instrumentation-close-the-connection:

Close the Connection
^^^^^^^^^^^^^^^^^^^^
To close our connection:

.. code-block:: python
  :linenos:
  :emphasize-lines: 3

  # RabbitMq chart construction above 
  # Chart start code and B signal injection above
  chart.connection.close()

The code to build our designed producer is complete.  Now let's see it's
terminal output on the raspberry pi:

.. _producer_output:

.. code-block:: guess

  ['START',
   'SEARCH_FOR_SUPER_SIGNAL:producer_outer',
   'ENTRY_SIGNAL:producer_outer',
   'INIT_SIGNAL:producer_outer',
   'SEARCH_FOR_SUPER_SIGNAL:c1',
   'ENTRY_SIGNAL:c1',
   'INIT_SIGNAL:c1',
   '<- Queued:(0) Deferred:(0)',
   'B:c1',
   'B:producer_outer',
   'EXIT_SIGNAL:c1',
   'EXIT_SIGNAL:producer_outer',
   'ENTRY_SIGNAL:producer_outer',
   'INIT_SIGNAL:producer_outer',
   'SEARCH_FOR_SUPER_SIGNAL:c1',
   'ENTRY_SIGNAL:c1',
   'INIT_SIGNAL:c1',
   '<- Queued:(0) Deferred:(0)']
  
  [2018-01-10 13:14:26.739622] [producer_192.168.1.72] e->start_at() top->c1
  [2018-01-10 13:14:27.024377] [producer_192.168.1.72] e->B() c1->c1

Comparing this to our :ref:`producer design<producer_design>` we see that it is
the expected spy and trace.  If we ran our trace through sequence we would see:

When we run the above trace through sequence see the following high level of
behavior:

.. code-block:: guess

  [ Chart: producer_192.168.1.72 ]
       top          c1      
        +start_at()->|
        |    (1)     |
        |            +            
        |             \ (2)       
        |             B()         
        |             /           
        |            <            

To summarize, we are expecting this trace and spy information to be passed as
individual encrypted messages to a different computer with 192.168.1.72 as an IP
address.

To see the full code example look at `c_trace_producer`_.

.. _networked_instrumentation-the-consumer-design:

The Consumer Design
-------------------
The consumer is significantly simpler than the producer. It needs to listen for
messages coming in from another node, decrypt them, then output them onto the
screen.

This design will be broken down into:

1. :ref:`Importing the required libraries<networked_instrumentation-report-the-required-libraries>`
2. :ref:`Creating a class with the required rabbitmq boiler plate<networked_instrumentation-add-the-rabbitmq-boiler-plat-code-and-ability-to-get-ip>`
3. :ref:`Adding a foreign hsm object to collection the spy and trace stream<networked_instrumentation-add-a-shutdown-count-and-a-foreignhsm-object>`
4. :ref:`Linking the network messages to callbacks<networked_instrumentation-link-our-messages-to-callback-functions>`
5. :ref:`Message decryption<networked_instrumentation-decrypt-our-messages>`
6. :ref:`Stopping the program and turning off the network connection<networked_instrumentation-turn-off-the-network-and-shutdown-the-program>`

.. _networked_instrumentation-report-the-required-libraries:

Import the Required Libraries
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
To begin with we will import the required libraries:

.. code-block:: python
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros.hsm import pp
  from cryptography.fernet import Fernet
  from functools import wraps

On line 1 we see that we will be using the ``pika`` rabbitMq Python library.
Line 3 introduces the ForeignHsm class, which is just an interface around the
spy and trace logs streaming in from another machine.  On line 5 we see we are
calling the Fermet crypto library which we will use for decrypting the messages
coming from the producer.

.. _networked_instrumentation-create-a-class-and-a-drawing-in-its-docstring:

Create a Class and a Drawing in its Docstring
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now we will define a LocalConsumer class which basically acts as a container of
functionality.  In it we will draw a picture of our network strategy in it's doc
string.

.. code-block:: python
  :emphasize-lines: 8-42
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros.hsm import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:
                  
                 |---> LocalConsumer spans this part of pic--->|
                  
                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):
      pass

.. _networked_instrumentation-add-the-rabbitmq-boiler-plat-code-and-ability-to-get-ip:

Add the RabbitMq Boiler Plat Code and Ability to get IP
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now we fill in the boiler plate rabbitMq code required to build two exchanges,
'spy' and 'trace', both using a 'fanout' strategy.  We create two new queues
that will destroy themselves one the program stops running, identify the name of
these queues and bind the exchange to the queue name.

This boiler plate code needs to know the local ip address.  This information is
obtained from the get_ip static method of the LocalConsumer class.

.. code-block:: python
  :emphasize-lines: 44-68, 70-81
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros.hsm import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:
                  
                 |---> LocalConsumer spans this part of pic--->|
                  
                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

  @staticmethod
  def get_ip():
    '''LocalConsumer.get_ip()'''
    ip = '127.0.0.1'
    s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
      # doesn't have to be reachable
      s.connect(('10.255.255.255', 1))
      ip = s.getsockname()[0]
    finally:
      s.close()
    return ip

.. _networked_instrumentation-add-a-shutdown-count-and-a-foreignhsm-object:

Add a Shutdown Count and a ForeignHsm Object
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
We need a way to shut down the program, so we will add a count that we can
compare against.  We will use this count later.

A foreign_hsm will be added, which will consume the spy and trace messages
emitted from the producer on the rasperry pi.  This foreign_hsm object will have
the same ``spy`` and ``trace`` methods of any other miros spy/trace supported
object.  However, if you look inside of the object, there is no event processor,
it is just a store of information with an interface that looks like a statechart
object.

.. code-block:: python
  :emphasize-lines: 70-73
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros.hsm import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:
                  
                 |---> LocalConsumer spans this part of pic--->|
                  
                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

      # keep a count so we can exit the program
      self.count = 0
      # make a ForeignHsm to track activity on another machine
      self.foreign_hsm = ForeignHsm()

  @staticmethod
  def get_ip():
    '''LocalConsumer.get_ip()'''
    ip = '127.0.0.1'
    s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
      # doesn't have to be reachable
      s.connect(('10.255.255.255', 1))
      ip = s.getsockname()[0]
    finally:
      s.close()
    return ip

.. _networked_instrumentation-link-our-messages-to-callback-functions:

Link our Messages to Callback Functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now we need to link the messages coming from the live spy and live trace on the
raspberry pi to a set of callbacks that do something interesting with this
information, like print this information to the terminal of my windows box.

.. code-block:: python
  :emphasize-lines: 76-80, 82-86, 88-91, 93-95
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros.hsm import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:
                  
                 |---> LocalConsumer spans this part of pic--->|
                  
                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

      # keep a count so we can exit the program
      self.count = 0
      # make a ForeignHsm to track activity on another machine
      self.foreign_hsm = ForeignHsm()
  

      def spy_callback(ch, method, properties, body):
        '''create a spy_callback function received messages in the queue'''
        foreign_spy_item = body
        self.foreign_hsm.append_to_spy(foreign_spy_item)
        print(" [x] Spy: {!s}".format(foreign_spy_item))

      def trace_callback(ch, method, properties, body):
        '''create a trace_callback function received messages in the queue'''
        foreign_trace_item = body
        self.foreign_hsm.append_to_trace(foreign_trace_item)
        print(" [x] Trace: {!s}".format(foreign_trace_item))

      # register the spy_callback and trace_callback with a queue
      self.channel.basic_consume(spy_callback,
          queue=spy_queue_name,
          no_ack=True)

      self.channel.basic_consume(trace_callback,
          queue=trace_queue_name,
          no_ack=True)

  @staticmethod
  def get_ip():
    '''LocalConsumer.get_ip()'''
    ip = '127.0.0.1'
    s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
      # doesn't have to be reachable
      s.connect(('10.255.255.255', 1))
      ip = s.getsockname()[0]
    finally:
      s.close()
    return ip

.. _networked_instrumentation-decrypt-our-messages:

Decrypt our Messages
^^^^^^^^^^^^^^^^^^^^

But wait, the messages are encrypted right?  So if we don't adjust our code we
will just print a nonsensical set of strings coming from the raspberry pi's
statechart.  We need to decrypt the messages.  To do this we will decorate the
callback function with a static decrypt method.

Finally, we will need to build an object of the class and run the code:

.. code-block:: python
  :emphasize-lines: 75, 82, 127-136, 109-118
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros.hsm import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:
                  
                 |---> LocalConsumer spans this part of pic--->|
                  
                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

      # keep a count so we can exit the program
      self.count = 0
      # make a ForeignHsm to track activity on another machine
      self.foreign_hsm = ForeignHsm()

      @LocalConsumer.decrypt
      def spy_callback(ch, method, properties, body):
        '''create a spy_callback function received messages in the queue'''
        foreign_spy_item = body
        self.foreign_hsm.append_to_spy(foreign_spy_item)
        print(" [x] Spy: {!s}".format(foreign_spy_item))

      @LocalConsumer.decrypt
      def trace_callback(ch, method, properties, body):
        '''create a trace_callback function received messages in the queue'''
        foreign_trace_item = body
        self.foreign_hsm.append_to_trace(foreign_trace_item)
        print(" [x] Trace: {!s}".format(foreign_trace_item))

      # register the spy_callback and trace_callback with a queue
      self.channel.basic_consume(spy_callback,   queue=spy_queue_name,   no_ack=True)
      self.channel.basic_consume(trace_callback, queue=trace_queue_name, no_ack=True)

    def start(self):
      self.channel.start_consuming()

    @staticmethod
    def get_ip():
      '''LocalConsumer.get_ip()'''
      ip = '127.0.0.1'
      s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      try:
        # doesn't have to be reachable
        s.connect(('10.255.255.255', 1))
        ip = s.getsockname()[0]
      finally:
        s.close()
      return ip

    @staticmethod
    def decrypt(fn):
      @wraps(fn)
      def _decrypt(ch, method, properties, cyphertext):
        '''LocalConsumer.decrypt()'''
        key = b'u3Uc-qAi9iiCv3fkBfRUAKrM1gH8w51-nVU8M8A73Jg='
        f = Fernet(key)
        plain_text = f.decrypt(cyphertext).decode()
        fn(ch, method, properties, plain_text)
      return _decrypt


  if __name__ == "__main__":
    local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')
    local_consumer.start()

.. _networked_instrumentation-turn-off-the-network-and-shutdown-the-program:

Turn off the Network and Shutdown the Program
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So, it's mostly there, but how to we stop it?  When asked on stackover flow the
``pika`` maintainer recommended a timeout callback that can call the
``stop_consuming`` method of the channel class.  So we will add a callback that
has a timer, references our count and can resubscribe itself if it is too soon
to quite.

.. code-block:: python
  :emphasize-lines: 89-102, 104-105
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros.hsm import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:
                  
                 |---> LocalConsumer spans this part of pic--->|
                  
                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

      # keep a count so we can exit the program
      self.count = 0
      # make a ForeignHsm to track activity on another machine
      self.foreign_hsm = ForeignHsm()

      @LocalConsumer.decrypt
      def spy_callback(ch, method, properties, body):
        '''create a spy_callback function received messages in the queue'''
        foreign_spy_item = body
        self.foreign_hsm.append_to_spy(foreign_spy_item)
        print(" [x] Spy: {!s}".format(foreign_spy_item))

      @LocalConsumer.decrypt
      def trace_callback(ch, method, properties, body):
        '''create a trace_callback function received messages in the queue'''
        foreign_trace_item = body
        self.foreign_hsm.append_to_trace(foreign_trace_item)
        print(" [x] Trace: {!s}".format(foreign_trace_item))

      def timeout_callback():
        '''callback for outputting the foreign trace and exiting the program'''
        spy = self.foreign_hsm.spy()
        if len(spy) is not 0:
          pp(self.foreign_hsm.spy())
          print(self.foreign_hsm.trace())
        self.count += 1
        # stop processing or reconnect this callback to a timer
        if self.count >= 30:
          self.channel.stop_consuming()
        else:
          self.connection.add_timeout(deadline=1, callback_method=timeout_callback)
          self.foreign_hsm.clear_spy()
          self.foreign_hsm.clear_trace()

      # Add the timeout callback
      self.connection.add_timeout(deadline=10, callback_method=timeout_callback)

      # register the spy_callback and trace_callback with a queue
      self.channel.basic_consume(spy_callback,   queue=spy_queue_name,   no_ack=True)
      self.channel.basic_consume(trace_callback, queue=trace_queue_name, no_ack=True)

    def start(self):
      self.channel.start_consuming()

    @staticmethod
    def get_ip():
      '''LocalConsumer.get_ip()'''
      ip = '127.0.0.1'
      s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      try:
        # doesn't have to be reachable
        s.connect(('10.255.255.255', 1))
        ip = s.getsockname()[0]
      finally:
        s.close()
      return ip

    @staticmethod
    def decrypt(fn):
      @wraps(fn)
      def _decrypt(ch, method, properties, cyphertext):
        '''LocalConsumer.decrypt()'''
        key = b'u3Uc-qAi9iiCv3fkBfRUAKrM1gH8w51-nVU8M8A73Jg='
        f = Fernet(key)
        plain_text = f.decrypt(cyphertext).decode()
        fn(ch, method, properties, plain_text)
      return _decrypt


  if __name__ == "__main__":
    local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')
    local_consumer.start()

Closing a program like this seems rather clumpsy.  In the future we will call
the ``stop_consuming`` method from within a statechart based on a state chart.

So there you have it, a full consumer.  Let's run it and the producer and see
what happens.

The consumer outputs:

.. code-block:: guess
  :linenos:

   [x] Trace: [2018-01-10 18:23:35.647035] [rabbit_producer_192.168.1.72] e->start_at() top->c1
   [x] Spy: START
   [x] Spy: SEARCH_FOR_SUPER_SIGNAL:producer_outer
   [x] Spy: ENTRY_SIGNAL:producer_outer
   [x] Spy: INIT_SIGNAL:producer_outer
   [x] Spy: SEARCH_FOR_SUPER_SIGNAL:c1
   [x] Spy: ENTRY_SIGNAL:c1
   [x] Spy: INIT_SIGNAL:c1
   [x] Spy: <- Queued:(0) Deferred:(0)
   [x] Trace: [2018-01-10 18:23:35.932470] [rabbit_producer_192.168.1.72] e->B() c1->c1
   [x] Spy: B:c1
   [x] Spy: B:producer_outer
   [x] Spy: EXIT_SIGNAL:c1
   [x] Spy: EXIT_SIGNAL:producer_outer
   [x] Spy: ENTRY_SIGNAL:producer_outer
   [x] Spy: INIT_SIGNAL:producer_outer
   [x] Spy: SEARCH_FOR_SUPER_SIGNAL:c1
   [x] Spy: ENTRY_SIGNAL:c1
   [x] Spy: INIT_SIGNAL:c1
   [x] Spy: <- Queued:(0) Deferred:(0)
  ['START',
   'SEARCH_FOR_SUPER_SIGNAL:producer_outer',
   'ENTRY_SIGNAL:producer_outer',
   'INIT_SIGNAL:producer_outer',
   'SEARCH_FOR_SUPER_SIGNAL:c1',
   'ENTRY_SIGNAL:c1',
   'INIT_SIGNAL:c1',
   '<- Queued:(0) Deferred:(0)',
   'B:c1',
   'B:producer_outer',
   'EXIT_SIGNAL:c1',
   'EXIT_SIGNAL:producer_outer',
   'ENTRY_SIGNAL:producer_outer',
   'INIT_SIGNAL:producer_outer',
   'SEARCH_FOR_SUPER_SIGNAL:c1',
   'ENTRY_SIGNAL:c1',
   'INIT_SIGNAL:c1',
   '<- Queued:(0) Deferred:(0)']
  [2018-01-10 18:23:35.647035] [rabbit_producer_192.168.1.72] e->start_at() top->c1
  [2018-01-10 18:23:35.932470] [rabbit_producer_192.168.1.72] e->B() c1->c1

So we see that the decryption worked and the live spy and trace messages were
being emitted onto the screen as they were recieved from the network.  We also
see that the foreign_hsm object's ``spy`` and ``trace`` methods output results
that might have come from a real statechart running on this machine.

To see the full consumer code, reference this `c_trace_consumer`_.

We have succeeded in aggregrating spy and trace messages generated on one
machine within another.

:ref:`back to examples <examples>`

.. _c_trace_consumer: https://github.com/aleph2c/miros/blob/master/examples/c_trace_consumer.py
.. _c_trace_producer: https://github.com/aleph2c/miros/blob/master/examples/c_trace_producer.py
.. _simple pub-sub: https://www.rabbitmq.com/tutorials/tutorial-three-python.html
.. _networked pub-sub send: https://github.com/aleph2c/miros/blob/master/experiment/rabbit/c_emit_log_fanout.py
.. _networked pub-sub receive: https://github.com/aleph2c/miros/blob/master/experiment/rabbit/c_receive_logs_fanout.py
