







<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Introduction | miros</title>
    <link rel="shortcut icon" href="_static/favicon.ico">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css">
    <link rel="stylesheet" href="_static/theme.css" type="text/css">
    
      
    <link rel="stylesheet" type="text/css" href="_static/css/miros_docs.css" />
      
    
    

    
    <script type="text/javascript" src="_static/theme.js" defer></script>
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    
    <script src="_static/jquery.js"></script>
    
    <script src="_static/underscore.js"></script>
    
    <script src="_static/doctools.js"></script>
    
    <script src="_static/language_data.js"></script>
    
    

    
      
      
    <link rel="index" title="Index" href="genindex.html">
      
      
    <link rel="search" title="Search" href="search.html">
      
      
      
    <link rel="next" title="Quick Start" href="quickstart.html">
      
      
    <link rel="prev" title="Installation" href="installation.html">
      
    

    

    

    
  </head>

  <body>
    <header class="main-header">
      <div class="navbar">
        <div id="js-sidebar-mask" class="sidebar-mask"></div>
        <div id="js-sidebar-menu-button" class="sidebar-menu-button">
          <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg>
        </div>
        <a href="index.html" class="site-link">
          
          miros
          
        </a>
        <div class="navbar-links">
          <a href="installation.html" class="navbar-link">Docs</a>
          
          <a href="https://github.com/aleph2c/miros" class="navbar-link">GitHub</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg>
          
        </div>
      </div>
    </header>

    <main class="main-wrapper">
      
      <div id="js-main-sidebar" class="main-sidebar">
        
        <div class="sidebar-content sidebar-content--divider sidebar-navbar-links">
          <a href="https://github.com/aleph2c/miros" class="sidebar-navbar-link">GitHub</a>
          <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg>
        </div>
        
        
        <div class="sidebar-content sidebar-logo">
    <a href="index.html">
      <img class="logo" src="_static/miros_logo.svg" alt="miros" >
    </a>
</div>
        
        

<h2 class="sidebar-heading">Contents</h2>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#about-this-documentation">About this Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#history-and-context">History and Context</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="zero_to_one.html">Tutorial: Zero To One</a></li>
<li class="toctree-l1"><a class="reference internal" href="reading_diagrams.html">Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes.html">Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="reflection.html">Reflection</a></li>
<li class="toctree-l1"><a class="reference internal" href="patterns.html">Patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Architecture</a></li>
</ul>

        
        
<h2 class="sidebar-heading">Useful Links</h2>

<ul>
  <li><a href="https://github.com/aleph2c/py-activeobject">miros on github</a></li>
  <li><a href="https://github.com/aleph2c/sequence">sequence on github</a></li>
  <li><a href="https://aleph2c.github.io/miros-rabbitmq/index.html">miros-rabbitmq plugin</a></li>
  <li><a href="http://www.umlet.com">UMLet Download</a></li>
  <li><a href="http://www.inf.ed.ac.uk/teaching/courses/seoc/2005_2006/resources/statecharts.pdf">formalism explained</a></li>
</ul>


<h2 class="sidebar-heading">For Embedded</h2>

<ul>
  <li><a href="https://state-machine.com/">Quantum Leaps for Embedded</a></li>
  <li><a href="https://github.com/QuantumLeaps/">Quantum Leaps On Github</a></li>
</ul>


<h2 class="sidebar-heading">Statechart Videos</h2>

<ul>
  <li><a href="https://www.mathworks.com/videos/understanding-state-machines-what-are-they-1-of-4-90488.html">Part 1 (What)</a></li>
  <li><a href="https://www.mathworks.com/videos/understanding-state-machines-why-use-them-2-of-4-90489.html">Part 2 (Why)</a></li>
  <li><a href="https://www.mathworks.com/videos/understanding-state-machines-what-are-they-1-of-4-90488.html">Part 3 (Mealy/Moore)</a></li>
  <li><a href="https://www.mathworks.com/videos/understanding-state-machines-harel-state-machines-4-of-4-90491.html">Part 4 (Harel Statecharts)</a></li>
  <li><a href="https://barrgroup.com/Embedded-Systems/How-To/Introduction-Hierarchical-State-Machines">Introduction to HSMs</a></li>
</ul>
        
        

<div id="searchbox" style="display: none" role="search">
  <h2 id="searchlabel" class="sidebar-heading">Quick search</h2>
  <div class="searchformwrapper sidebar-content">
    <form class="search" action="search.html" method="get">
      <input class="sidebar-search sidebar-search--input" type="text" name="q" aria-labelledby="searchlabel"><input class="sidebar-search sidebar-search--btn" type="submit" value="Go">
    </form>
  </div>
</div>
<script>$('#searchbox').show(0);</script>

        
      </div>
      

      
      <div class="main-content main-content--sidebar">
      
        
          
  <blockquote class="epigraph" id="introduction-introduction">
<div><p>Decisions without actions are pointless. Actions without decisions are reckless.</p>
<p class="attribution">—John Boyd</p>
</div></blockquote>
<div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h1>
<p>This library ports the <a class="reference external" href="https://www.state-machine.com/psicc2/">Miro Samek event processor</a> to Python.  If you use this
library to prototype your designs in Python, it should be a straight forward
process to port them back to his  <a class="reference external" href="http://www.state-machine.com/">QP framework</a> for a huge performance gain.</p>
<div class="section" id="about-this-documentation">
<h2>About this Documentation<a class="headerlink" href="#about-this-documentation" title="Permalink to this headline">#</a></h2>
<p>Statecharts provide a powerful programming technique which can be used to map
complex behavior into a set of very small and simple diagrams.  When I was first
introduced to the technique as a junior developer, I found it baffling.  This is
the documentation I wish someone had given to me back then.</p>
<p>The technique for drawing a statechart was absorbed by the UML movement in the
1990’s.  UML is obsolete, it can’t begin to describe the expressive power of
Python, but it can be used to sketch out your ideas well enough so that someone
else can understand what you mean.  I can’t expect you to know UML; so part of this
documentation <span class="xref std std-ref">explains how to draw your pictures</span>.</p>
<p>If you are new to statecharts, the statechart concepts and mechanics are
explained through stories and tutorials in <a class="reference internal" href="zero_to_one.html#zero-to-one-zero-to-one"><span class="std std-ref">zero to one</span></a>.</p>
<p>If you already understand statecharts, you can immediately jump to the
<a class="reference internal" href="quickstart.html#quick-start"><span class="std std-ref">quick start</span></a> and look at how I implemented a networked,
robotic sprinkler using the open weather API with miros in Python.  It
demonstrates 3 different concurrent statecharts working together.</p>
<p>Miro Samek pulled a lot of the difficult parts of statechart specification out
of his code to make it compact and fast.  Then he spent an entire chapter of his
<a class="reference external" href="http://www.state-machine.com/psicc2/">latest book</a> showing how to regain
these features by making simple adjustments to your code; he called this section
patterns.  In the <a class="reference internal" href="patterns.html#patterns"><span class="std std-ref">pattern section</span></a>, I demonstrate how to
implement Miro’s patterns and then show a few more.</p>
<p>The <a class="reference internal" href="recipes.html#recipes"><span class="std std-ref">recipes section</span></a> contains a list of things that you might
want to do and a concise example of how to do it.</p>
<p>The <a class="reference internal" href="examples.html#examples"><span class="std std-ref">examples section</span></a> contain some more extended examples which
can be referenced and then extended for your own designs.</p>
<p>The <a class="reference internal" href="reflection.html#reflection"><span class="std std-ref">reflection section</span></a> goes into the details about how to
use the instrumentation that has been built into the miros library.  Two
different types of sensible logging have been added to this miros, you can use
them to see how your statechart is reacting to its environment.</p>
<p>The <a class="reference internal" href="testing.html#testing-testing"><span class="std std-ref">testing section</span></a> will demonstrate a set of simple
patterns so that you can verify your designs are working as you expect them to.</p>
<p>Finally, if you would like to link your statecharts across a computer network
(for IOT applications), you can use the <a class="reference external" href="https://aleph2c.github.io/miros-rabbitmq/index.html">miros-rabbitmq</a> plugin.</p>
</div>
<div class="section" id="history-and-context">
<span id="introduction-history-and-context"></span><h2>History and Context<a class="headerlink" href="#history-and-context" title="Permalink to this headline">#</a></h2>
<blockquote class="epigraph">
<div><p>I made up the term object-oriented, and I can tell you I did not have C++ in mind.</p>
<p class="attribution">—Alan Kay</p>
</div></blockquote>
<p>When <a class="reference external" href="https://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a> invented
object-oriented programming (circa 1966), he was inspired by biology. He saw
plants and animals as extremely complicated systems of systems, made up of cells
who’s inner states and clocks were hidden from one another. The only way that
these cells could work together was by producing small chemical messages and
exchanging them with their adjacent cells. He saw this as a great analogy for
managing complexity.  He invented a programming language called, <a class="reference external" href="https://pdfs.semanticscholar.org/442f/0f5205c7d4674612204ecc8357367dabbf45.pdf">smalltalk</a>,
and the parts of it which he modeled from the cell, he called <code class="docutils literal notranslate"><span class="pre">objects</span></code>.</p>
<a class="reference external image-reference" href="https://lms.biotecnika.org/course/csir-net-unit-4-cell-communication-cell-signalling/"><img alt="_images/cell-communication-and-signalling.jpg" class="scale-to-fit" src="_images/cell-communication-and-signalling.jpg" /></a>
<p>Message passing was an essential and misunderstood part of his original vision.
As modern OOP (C++) programming languages were developed, their designers
parsimoniously moved functions into data structures and called these
data/function collections, <strong>classes</strong>. The act of constructing one of these
Frankenstein structures (a class), was called “instantiation of an <strong>object</strong>”. But
this object term was a redefinition of Alan Kay’s word because its way of
message passing could halt and stutter the entire collective system. To pass a
message using C++, was just to call a function in another object and if the
function call had to wait for some IO to come in from a computer peripheral,
then all of the other objects in the system would have to wait too. This meant
that all of the C++ system cells were temporally coupled together since they
shared the same synchronous clock. Nature doesn’t work like this, if your cells
suddenly started to operate this way, you would keel over dead in seconds. Alan
Kay’s original biological metaphor of an object was broken. He ended up having
to call his objects, <strong>real objects</strong>, instead of objects, because the OOP language
which he invented, was <a class="reference external" href="https://www.quora.com/What-did-Alan-Kay-mean-by-I-made-up-the-term-object-oriented-and-I-can-tell-you-I-did-not-have-C++-in-mind">colonized by the C++ popular culture</a>.</p>
<p>But statecharts build from the miros library, each act as if they were running
on their own computer, so they can pass messages like cells pass messages. When
a message is passed this way, it is called an <strong>event</strong>. This means that we have to
re-name our objects to something else to differentiate them from instantiated
Frankenstein-structures, very much like Alan Kay did. An object that runs in
its own thread is called an <a class="reference external" href="https://en.wikipedia.org/wiki/Active_object">active object</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The miros library lets you pass messages in three ways:</p>
<ul class="simple">
<li><p>traditional method synchronous calls are supported</p></li>
<li><p>active objects can subscribe to and publish asynchronous public events (messages outside of the cell)</p></li>
<li><p>active objects can send and consume private asynchronous events (messages inside of the cell)</p></li>
</ul>
</div>
<p>The events act like the simple chemical messages that are shared between cells.
When an event is published, the active object that produced it goes back to its
business, it is not blocked like it would be if it made a function call or a
method call. It can do this because it has its own thread (it runs like it owns
its own computer). This ability to process in parallel is called
<strong>orthogonality</strong> in statechart theory.</p>
<p>The <strong>statechart</strong> was invented by the Mathematician <a class="reference external" href="https://en.wikipedia.org/wiki/David_Harel">David Harel</a> in 1983 as a conceptual tool to
help the avionics industry manage their engineering complexity. Instead of
working from a metaphor, David Harel’s innovations occurred while working
shoulder to shoulder with Israeli software engineers, while he watched them
build a jet fighter. He noticed that they could answer questions like, “What
algorithm is used by the radar to measure the distance to a target?”, but they
did not have answers to questions that seemed more basic, such as “What happens
when you press this button […] under all possible circumstances?” After asking
such questions, he would watch the engineers dive into a two-volume, 2000 page
document; attempting to cross-reference different parts of the tome, written by
different authors.</p>
<a class="reference external image-reference" href="https://www.lemonde.fr/blog/binaire/files/2015/04/statechart.png"><img alt="_images/DavidHarel.png" class="scale-to-fit" src="_images/DavidHarel.png" /></a>
<p>Many large scale engineering disasters occur due to “interface failures,” not as
a result of a single component failure, but as a failure of those parts to
interface properly with one another. The interface failures are the direct
result of teams not having answers to the simple-seeming questions that David
Harel asked his avionics team.</p>
<p>We are lucky that David Harel comes from a strong background in mathematical
topology and not from a programming perspective. He watched the engineers like
an anthropologist would have, and mapped how they talked about things into
simple topological maps; often on napkins. He didn’t try to imagine how to
program their descriptions but specifically focused on how to draw a picture of
what they said, then thought of a way to formalize the pictures into a set of
rules. The rules were simple enough that anyone looking at the diagram could
quickly understand what would have otherwise taken pages to write down. The
pictures described different working parts of the systems as <strong>states</strong>, and
often, these states of operation would also contain the behaviour of other
states. From this, he formalized the notion of a <strong>hierarchical state machine
(HSM)</strong>. Using this formalism (rules for mapping ideas into pictures), it was
possible to build a software framework that could take pages and pages of a
complex specification, convert it into a compacted diagram that could quickly be
understood by another person, or a team, and compile it into working software.
This was a massive contribution to computing.  Despite this, it took David Harel
over three years to get his work published:</p>
<blockquote class="epigraph">
<div><p>I find the concept of statecharts to be quite interesting, but unfortunately only to a small segment of our readership. I find the information presented to be somewhat innovative but not wholly new. I feel that the use of the digital watch example to be useful, but somewhat simple in the light of what our readership would be looking for.</p>
<p class="attribution">—<strong>Rejection letter to Dr. David Harel from the IEEE (1983)</strong>: <a class="reference external" href="http://www.inf.ed.ac.uk/teaching/courses/seoc/2005_2006/resources/statecharts.pdf">Regarding this paper</a> which has since had over 8000 citations.</p>
</div></blockquote>
<p>Converting complex specifications into software and releasing software is just
the start of things though. It has been empirically demonstrated that the
majority of a software’s cost goes into its maintenance cycle. Even when we are
building new software, the majority of our time goes into troubleshooting our
creations. A difficult thing to do as a developer is to create a cognitive
picture of the code which is in front of us. Even harder is to challenge our own
assumptions as we try to see why our cognitive picture isn’t working as we
expect.</p>
<p>If we had a easily understood picture of our design, like a map, troubleshooting
old code would be much more comfortable. We wouldn’t have to scan the code to
build a mental diagram, the diagram would be given to us as a gift from the
past, leaving our working memory available for solving problems.</p>
<p>But we tried drawing pictures before in the 1990s with <strong>UML</strong> (<a class="reference external" href="https://www.uml.org/">Universal
Modeling Language</a>). The group behind this movement
promised systems-understanding through pictures. To do this, they pulled
together 14 different ways that people were drawing software systems into one
standard.</p>
<p>Then the movement lost momentum because they tried to turn their pictures into
its own programming language.  More and more icons got added, weirder names
where invented, and the pictures and theory created social skisms between
“architects” and the practitioners who actually wrote the code.  Also, UML
emphasized class diagrams without statechart diagrams.</p>
<p>A class diagram only shows how the code is structured, but a statechart diagram
tells you how the code will behave.</p>
<a class="reference external image-reference" href="_static/intro_1.pdf"><img alt="_images/intro_1.svg" class="scale-to-fit" src="_images/intro_1.svg" /></a>
<p>It is easy to manifest a class diagram in Python since Python started as an
object-oriented programming language of the C++ family. But how do you create
the code that is described by a behavioural statechart diagram? Well, that’s the
point of this library: it provides you with the syntax, concurrency, queuing
and messaging infrastructure needed to make it work in Python.</p>
<p>To create machine code from a picture is called <a class="reference external" href="https://en.wikipedia.org/wiki/Model-driven_engineering">model-driven development</a>.  Model-driven
software is typically proprietary, niched to a specific problem space and
expensive. When statecharts first started to gain momentum in the late 1990s,
the only way to access their expressive power was to spend a lot of money on
this kind of proprietary software.</p>
<p>David Harel was involved in a few of these software companies, and as a result,
he was placed in an economical conundrum. If he demonstrated how to implement
his theory, he would be giving competing software firms his IP. If he didn’t
describe how to apply his theory to actual practitioners, then it would lose
momentum, and his idea wouldn’t spread the way he wanted it to. When asked to
describe statechart semantics, his firm explained one way of doing it externally
while using another way internally. The language and the mechanisms of how to
implement his vision became confused, and the UML standards that described
statecharts ended up containing contradictions, which led to fragmentation.</p>
<p>In the early 2000s <strong>Dr. Miro Samek</strong> liberated statechart theory from
proprietary model-driven software by implementing a statechart framework in
c/C++, and then he showed everyone how he did it. He wrote two different books
and a series of articles.  Miro Samek took a <cite>code-centric</cite> approach, so that it
made sense to people who actually program; showing how to build his framework
using c/C++ in his code listings. If you were to become confused by a term or a
diagram, you could just look at his working code and see what he meant.</p>
<p>As a firmware developer, Dr. Samek ran into the tight memory and processing
constraints that confine a developer while they write code for small processors.
He refactored the Harel formalism to be more performant and practical. Then he
published the code that solves the topological problems needed to make it easy
for a statechart designer to translate their pictures into working solutions,
without having to solve these problems themselves; he called this code the <strong>event
processor</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This library uses Miros Samek’s event processing algorithm, and his way of
thinking about the problem space: this is why it is called miros.</p>
<p>If you would like to translate your design into <a class="reference external" href="https://www.state-machine.com/">Miro Samek’s QP framework</a> (for a considerable performance gain), it
should be reasonably straight forward to port your Python code to c/C++.</p>
<p>Miro Samek provides his code for free but requires a small payment if you use it
in your product. In return for this payment, you get access to a world-class
developer, his supporting documentation, and you know that his project will
continue to evolve and improve for your next product.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Miro Samek then demonstrated how to get rid of the real-time-OS entirely, how
to build a real-time, concurrent system using an event loop (circa 2000). His
approach is similar to the event loops provided by twisted and asycio in
Python.</p>
</div>
<p><strong>There was still a need to draw pictures</strong>, so Miro Samek gave away his programmed
<a class="reference external" href="http://www.state-machine.com/downloads/visio2003.zip">stencils</a> for the
Microsoft Visio drawing package, and he recommended free drawing tools like
<a class="reference external" href="http://www.umlet.com">UMLet</a>.</p>
<p>What he didn’t do was to create his own language, he used existing languages so
that a firm wouldn’t have to re-write all of their code. Miro Samek had turned
c/C++ into something that was more in line with Alan Kay’s original vision of an
object-oriented programming language and with the expressive power of
statecharts.</p>
<p>Meanwhile, the software community moved on. UML was used by less and less firms
because the pictures of software structure provided by class diagrams just
weren’t that useful to practitioners. Proprietary languages started to lose
ground to open source languages. Model Driven tools were asymmetric, you could
change the model to make code, but if you changed the code, the picture wouldn’t
update.</p>
<p>But UML never really went away, here are the google trends for the term “UML”
from 2004 to June 2019 (it’s currently very popular in China):</p>
<a class="reference external image-reference" href="_static/google_trends_UML_2004_to_2019.PNG"><img alt="_images/google_trends_UML_2004_to_2019.PNG" class="noscale-center" src="_images/google_trends_UML_2004_to_2019.PNG" /></a>
<p>As a result, there are still open source UML drawing packages in circulation.
These drawing packages overemphasize the class drawing aspects of UML, but <a class="reference external" href="http://www.umlet.com">UMLet</a>
for one has enough expressive power to describe statecharts too. You won’t want
to use them to make marketing documentation, but they are good enough to keep
your drawings small, expressive and easy to change.</p>
<p>To use this library is to program in Python, not pictures; so <strong>there is no
picture-to-code compiler here</strong>. This means you can use whatever picture drawing
technology you want. I use <a class="reference external" href="http://www.umlet.com">UMLet</a>, but if you find something better, email me
about it.</p>
<div class="toctree-wrapper compound">
</div>
</div>
</div>


        
        <div class="main-content__right-sidebar">
          <h2 class="sidebar-heading">On this page:</h2>
        </div>
      </div>
    </main>

    <div class="footer-wrapper">
      
      <footer class="main-footer main-footer--sidebar">
      
        <div class="relational-links">
          <div>
            
            ← <a class="relational-link" href="installation.html" title="previous chapter">Installation</a>
            
          </div>
          <div>
            
             <a class="relational-link" href="quickstart.html" title="next chapter">Quick Start</a> →
            
          </div>
        </div>
        
        <div class="copyright">
          © Copyright <span class="js-year"></span>,
          
          <a href="https://github.com/aleph2c" class="copyright_link">Scott Volk</a>.
          
        </div>
        
        
        <div class="last-updated">
          <span class="prefix">Last updated:</span>
          <span class="time">Jul 02, 2020 12:46 PM</span>
        </div>
        
        
        <div class="created-with">
          Created using <a href="http://sphinx-doc.org/" class="copyright_link">Sphinx</a> 3.1.1 with <span class="theme">13ds_theme_one</span>.
        </div>
        
      </footer>
    </div>
  </body>
</html>