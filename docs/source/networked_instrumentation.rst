.. _networked_instrumentation-spy-and-trace-across-a-network:

Spy and Trace Across a Network
==============================

.. _networked_instrumentation-context:

Context
-------
The spy and trace tools are handy for designing, debugging, testing and
documenting the behaviour of your statecharts.

But how would you view the spy and trace information from different statecharts,
running on different computers, across a network?

It would be useful if you could send the spy and trace information from one
machine to another and aggregate it in one location.  This way you could view
the instrumentation results of all of your networked state machines as if they
were running in one place.

In this example, I will run a statechart on one computer, then view its spy and
trace log on another.

.. _networked_instrumentation-getting-the-required-libraries:

Getting the Required Libraries
------------------------------

Up until now, I have only been using ``miros`` and the Python standard library.
To make this example work, you will have to install ``pika`` for messaging with
:ref:`RabbitMq<setting_up_rabbit_mq-setting-up-rabbit-mq>` and ``cryptography``
for encrypting your messages.  So let's do that now:

.. code-block:: shell

  pip3 install pika cryptography --user


.. _networked_instrumentation-setting-up-and-network-and-messaging:

Setting Up and Network and Messaging
------------------------------------
This example is going to use RabbitMq for messaging. RabbitMq is a robust
messaging platform, but to use it you must first set it up on all of your
computers. I have written how to do that :ref:`here<setting_up_rabbit_mq-setting-up-rabbit-mq>`.

When I constructed this example, I placed a statechart on a raspberry pi,
running Linux and had it send messages to a program running on a Windows 10
machine. To use the RabbitMq terminology the script running on my raspberry pi
was a producer because it was producing information. The spy and trace
aggregator running on Windows was the consumer since it consumed the messages
generated elsewhere.

To keep things as simple as possible, I wrote a ForeignHsm class which could
accept spy and trace logs. To access these logs, you would use its ``spy`` and ``trace``
methods, just like you would with any other statechart. So the ForeignHsm object
will live on the consumer since it will consume the spy and trace logs generated
by the statechart running on the raspberry pi.

RabbitMq has a variety of different messaging routing techniques. Our
aggregation consumer will want to receive all messages from the foreign
statechart. If I decided to run this consumer in two different threads in
Windows, I would want each of them to see all of the messages generated by the
raspberry pi. For this reason, I used the fanout routing technique offered by
RabbitMq. This fanout technique ensures that every connected consumer sees any
message generated by a producer.

.. _networked_instrumentation-example-design-specification:

Example Design Specification
----------------------------

To begin the example, I will write a specification:

* A statechart on one machine should have its spy and trace output on another
* All messages should be encrypted while on the network
* A producer can be run multiple times in unison.  If this happens, all
  connected consumers should receive all spy and trace information generated by
  each of the producers.
* A consumer should be able to be run multiple times in unison.  If this
  happens, each consumer should receive all messages generated by each producer
  in the network.

.. note::

  If you would like to skip the explanations and just look at the code, it's here:

  .. include:: i_networking_instrumentation_file_table.rst


Now let's try to build something that meets our design goals.

.. _networked_instrumentation-the-producer-design:

The Producer Design
-------------------

I'll start with the producer's code, let's call it `c_trace_producer`_ to show
that it is based on the `3rd (c) example
<https://www.rabbitmq.com/tutorials/tutorial-three-python.html>`_ provided by
the rabbitmq team.  If you haven't gone through these tutorials, here is a link
to their tutorial and a link to my code that extends their example so that
it works across a network:

===================  ======================= ===================================
Tutorial Purpose     RabbitMQ Pika Tutorial  Networked Version of their Tutorial
===================  ======================= ===================================
- Publish/Subscribe   `simple pub-sub`_      - `networked pub-sub send`_
                                             - `networked pub-sub receive`_
===================  ======================= ===================================

If you are feeling comfortable enough with programming RabbitMq with ``pika``,
then let us move on and design the producer:

.. _producer_design:

.. image:: _static/rabbit_chart_producer_1.svg
    :target: _static/rabbit_chart_producer_1.pdf
    :class: scale-to-fit

Above we see the UML diagram for the RabbitProducer.  It is mostly just a
Factory with some additional attributes to track a rabbitMq connection.

This RabbitProducer class is in the `c_trace_producer`_ file.  It
contains all of the statechart features that a Factory class has and the
additional capability of sending messages across a network.

The RabbitMq messaging strategy is drawn into the diagram as the coloured part.
It will consist of a spy and a trace producer, each transmitting messages into
their exchanges, which will in turn, spit their messages onto the network.

The information that feeds these producers will come from the spy and trace
logs being generated by the statechart as it reacts to events.  We will start
the chart, then send a B signal to it, then turn off the connection.

If we ever intend on building a producer with this technology, we will have to
hide its messages while they are on the big-bad-internet.  For this reason, the
example will also demonstrate a straightforward form of encryption.

Now that we have a design, we will begin to build it by:

1. :ref:`making a class that can send information on the network<networked_instrumentation-making-a-class-that-can-send-information-on-the-network>`
2. :ref:`connecting the output of our spy and trace logs to the network<networked_instrumentation-connect-the-output-of-our-spy-and-trace-logs-to-the-network>`
3. :ref:`creating the statechart's HSM<networked_instrumentation-create-the-statecharts-hsm>`
4. :ref:`making our statechart react to some events<networked_instrumentation-have-our-statechart-reat-to-some-events>`
5. :ref:`closing the connection<networked_instrumentation-close-the-connection>`

.. _networked_instrumentation-making-a-class-that-can-send-information-on-the-network:

Making a Class that can Send Information on the Network
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. _networked_instrumentation-subsubsection_titl:

Let's begin framing in the RabbitProducer class:

.. code-block:: python
  :emphasize-lines: 3, 14, 15
  :linenos:

  class RabbitProducer(Factory):
    def __init__(self, chart_name, rabbit_user, rabbit_password, ip, port):
      super().__init__(chart_name + '_' + ip)
      self.rabbit_user = rabbit_user
      self.rabbit_password = rabbit_password
      self.destination_ip = ip
      self.destination_port = port

      credentials = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters = pika.ConnectionParameters(ip, port, '/', credentials)
      self.connection = pika.BlockingConnection(parameters=parameters)

      self.channel = self.connection.channel()
      self.channel.exchange_declare(exchange='spy', exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')


Line 3 shows where we append the consumer's IP address to the statechart name.

The rest of the code is boiler plate rabbitMq code except for line 14 and 15.
Here we see that we are declaring two separate exchanges, both using the
`fanout` routing strategy.

The `fanout` strategy will ensure that any consumer who is subscribing to one of
these exchanges will get all of its messages.

.. _networked_instrumentation-connect-the-output-of-our-spy-and-trace-logs-to-the-network:

Connect the output of our Spy and Trace Logs to the Network
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now that we have something that can send messages over a network let's wire it
to the logs emitted by our statechart:

.. code-block:: python
  :emphasize-lines: 17-23, 25-33, 35-41, 43-50, 52-55
  :linenos:

  class RabbitProducer(Factory):
    def __init__(self, chart_name, rabbit_user, rabbit_password, ip, port):
      super().__init__(chart_name + '_' + ip)
      self.rabbit_user = rabbit_user
      self.rabbit_password = rabbit_password
      self.destination_ip = ip
      self.destination_port = port

      credentials = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters = pika.ConnectionParameters(ip, port, '/', credentials)
      self.connection = pika.BlockingConnection(parameters=parameters)

      self.channel = self.connection.channel()
      self.channel.exchange_declare(exchange='spy', exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      def strip_trace(fn):
        @wraps(fn)
        def _strip_trace(trace_live):
          trace_live = trace_live.replace("\n", "")
          # encrypt
          fn(trace_live)
        return _strip_trace

      def encrypt(fn):
        @wraps(fn)
        def _encrypt(plain_text):
          key = b'u3Uc-qAi9iiCv3fkBfRUAKrM1gH8w51-nVU8M8A73Jg='
          f = Fernet(key)
          cyphertext = f.encrypt(plain_text.encode())
          # broadcast_trace/broadcast_spy
          fn(cyphertext)
        return _encrypt

      @encrypt
      def broadcast_spy(spy_live):
        self.channel.basic_publish(
            exchange='spy',
            routing_key='',
            body=spy_live
        )

      @strip_trace
      @encrypt
      def broadcast_trace(trace_live):
        self.channel.basic_publish(
            exchange='trace',
            routing_key='',
            body=trace_live
        )

      self.register_live_spy_callback(broadcast_spy)
      self.register_live_trace_callback(broadcast_trace)
      self.live_spy   = True
      self.live_trace = True

The newly added code is highlighted.

I'm going to ask you to look at the new code out of sequence.  Let's begin with
lines 54 and 55.  Here we see we are turning on the live spy and trace logging
for the statechart.

On lines 52 and 53 we are calling the ``register_live_spy_callback`` and
``register_live_trace_callback`` to allow us to over-write the live spy and
trace behavior.  Instead of just outputting information to a terminal, we send
information into the provided functions.  So for instance, anytime our
statechart emits an item to its spy instrumentation it will send this to the
``broadcast_spy`` function instead.

The ``broadcast_spy`` function is defined within the ``__init__`` method scope
to enclose the ``self.channel`` object.  I wrote it this way because the
``pika`` callback signature only has one argument, the ``spy_live`` argument.  It doesn't
accept ``self``, and I need access to the ``self`` attribute to gain access to
the network.  I'm sure there is a neat way to get around this limitation, but I
didn't think about it too hard since I knew I could solve the issue with a
closure.

Both the ``broadcast_spy`` and ``broadcast_trace`` callback functions can send
strings across the network.  We see these functions are both decorated with
``encrypt``.  This means that before they do their business, their input is sent
to the ``encrypt`` function defined on line 27.

.. note::
  There are two main encryption libraries for Python, one is ``cryptography``
  and the other is ``pycrypto``.  Use ``cryptography`` since ``pycrypto`` will
  crash on windows.

Take note of the key, the consumer will have to have the same key, or it will
not be able to make sense of the messages sent to it.

The code is cluttered a bit with the ``strip_trace`` decorator, which removes
the newline characters for the trace stream.  I left it in the example because
you might want to follow this pattern for sprucing up your messages prior to
sending them out over the network.

.. _networked_instrumentation-create-the-statecharts-hsm:

Create the Statechart's HSM
^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now we create a RabbitProducer chart and add a hierarchical state machine to it.
The newly added code is highlighted:

.. code-block:: python
  :emphasize-lines: 58-67, 70-72, 75-77, 80-82, 85-91, 93-96, 98-100, 102-104, 106-108
  :linenos:

  class RabbitProducer(Factory):
    def __init__(self, chart_name, rabbit_user, rabbit_password, ip, port):
      super().__init__(chart_name + '_' + ip)
      self.rabbit_user = rabbit_user
      self.rabbit_password = rabbit_password
      self.destination_ip = ip
      self.destination_port = port

      credentials = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters = pika.ConnectionParameters(ip, port, '/', credentials)
      self.connection = pika.BlockingConnection(parameters=parameters)

      self.channel = self.connection.channel()
      self.channel.exchange_declare(exchange='spy', exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      def strip_trace(fn):
        @wraps(fn)
        def _strip_trace(trace_live):
          trace_live = trace_live.replace("\n", "")
          # broadcast_trace
          fn(trace_live)
        return _strip_trace

      def encrypt(fn):
        @wraps(fn)
        def _encrypt(plain_text):
          key = b'u3Uc-qAi9iiCv3fkBfRUAKrM1gH8w51-nVU8M8A73Jg='
          f = Fernet(key)
          cyphertext = f.encrypt(plain_text.encode())
          # broadcast_trace/broadcast_spy
          fn(cyphertext)
        return _encrypt

      @encrypt
      def broadcast_spy(spy_live):
        self.channel.basic_publish(
            exchange='spy',
            routing_key='',
            body=spy_live
        )

      @strip_trace
      @encrypt
      def broadcast_trace(trace_live):
        self.channel.basic_publish(
            exchange='trace',
            routing_key='',
            body=trace_live
        )

      self.register_live_spy_callback(broadcast_spy)
      self.register_live_trace_callback(broadcast_trace)
      self.live_spy   = True
      self.live_trace = True


  #  +-------- producer_outer ---------+
  #  |   +--- c1 ----+   +---- c2 ---+ |
  #  | * |           |   |           | +--+
  #  | | |           +-A->           | |  |
  #  | +->           <-A-+           | |  B
  #  |   |           |   |           | <--+
  #  |   +-----------+   +-----------+ |
  #  +---------------------------------+
  def producer_outer_init(chart, e):
    return chart.trans(c1)


  def producer_outer_B(chart, e):
    status = chart.trans(producer_outer)
    return status


  def c1_A(chart, e):
    status = chart.trans(c2)
    return status


  def c2_A(chart, e):
    status = chart.trans(c1)
    return status


  chart = RabbitProducer(
    chart_name="producer",
    rabbit_user="bob",
    rabbit_password="dobbs",
    ip="192.168.1.72",
    port=5672
  )

  producer_outer = chart.create(state='producer_outer'). \
    catch(signal=signals.INIT_SIGNAL, handler=producer_outer_init). \
    catch(signal=signals.B, handler=producer_outer_B). \
    to_method()

  c1 = chart.create(state='c1'). \
    catch(signal=signals.A, handler=c1_A). \
    to_method()

  c2 = chart.create(state='c2'). \
    catch(signal=signals.A, handler=c2_A). \
    to_method()

  chart.nest(producer_outer, parent=None). \
    nest(c1, parent=producer_outer). \
    nest(c2, parent=producer_outer)

On lines 58-65 we see an ASCII-art version of the statechart we are trying to
build.  On lines 70 through 82 we see the state method callbacks which will be
used to provide their arrows on the diagram.

On lines 85-91, we see that we are constructing a chart which will emit logs to
a foreign consumer.  While building up this object, we provide the credentials
required to dispatch from the local RabbitMq server.

On lines 93-104 we create the state methods, linking callbacks to specific
signal names.

Finally, on lines 106 to 108 we add the chart's hierarchy, using the ``nest``
method.

.. _networked_instrumentation-have-our-statechart-reat-to-some-events:

Have our statechart React to some Events
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The full RabbitMq chart has been built and linked to its thread with access to a
rabbitMq server and thereby it has access to the whole internet.

Now it is time to start our chart and watch it change its state.  We will start
it in the producer_outer state, wait, then send a ``B`` signal to it.

.. code-block:: python
  :emphasize-lines: 2-6

  # RabbitMq chart construction above
  chart.start_at(producer_outer)
  chart.post_fifo(Event(signal=signals.B))
  time.sleep(0.1)
  pp(chart.spy())
  print(chart.trace())

.. _networked_instrumentation-close-the-connection:

Close the Connection
^^^^^^^^^^^^^^^^^^^^
To close our connection:

.. code-block:: python
  :emphasize-lines: 3

  # RabbitMq chart construction above
  # Chart start code and B signal injection above
  chart.connection.close()

The code to build our designed producer is complete.  Now let's see its
terminal output on the raspberry pi:

.. _producer_output:

.. code-block:: guess

  ['START',
   'SEARCH_FOR_SUPER_SIGNAL:producer_outer',
   'ENTRY_SIGNAL:producer_outer',
   'INIT_SIGNAL:producer_outer',
   'SEARCH_FOR_SUPER_SIGNAL:c1',
   'ENTRY_SIGNAL:c1',
   'INIT_SIGNAL:c1',
   '<- Queued:(0) Deferred:(0)',
   'B:c1',
   'B:producer_outer',
   'EXIT_SIGNAL:c1',
   'EXIT_SIGNAL:producer_outer',
   'ENTRY_SIGNAL:producer_outer',
   'INIT_SIGNAL:producer_outer',
   'SEARCH_FOR_SUPER_SIGNAL:c1',
   'ENTRY_SIGNAL:c1',
   'INIT_SIGNAL:c1',
   '<- Queued:(0) Deferred:(0)']

  [2018-01-10 13:14:26.739622] [producer_192.168.1.72] e->start_at() top->c1
  [2018-01-10 13:14:27.024377] [producer_192.168.1.72] e->B() c1->c1

Comparing this to our :ref:`producer design<producer_design>` we see that it is
the expected spy and trace.  If we ran our trace through sequence we would see:

.. code-block:: guess

  [ Chart: producer_192.168.1.72 ]
       top          c1
        +start_at()->|
        |    (1)     |
        |            +
        |             \ (2)
        |             B()
        |             /
        |            <

To summarize, we are expecting this trace and spy information to be passed as
individual encrypted messages to a different computer with 192.168.1.72 as an IP
address.

To see the full code example look at `c_trace_producer`_.

.. _networked_instrumentation-the-consumer-design:

The Consumer Design
-------------------

The consumer is significantly more straightforward than the producer. It needs
to listen for messages coming in from another node, decrypt them, then output
them onto the screen.

This design will be broken down into:

1. :ref:`Importing the required libraries<networked_instrumentation-report-the-required-libraries>`
2. :ref:`Creating a class with the required rabbitmq boiler plate<networked_instrumentation-add-the-rabbitmq-boiler-plat-code-and-ability-to-get-ip>`
3. :ref:`Adding a foreign hsm object to collection the spy and trace stream<networked_instrumentation-add-a-shutdown-count-and-a-foreignhsm-object>`
4. :ref:`Linking the network messages to callbacks<networked_instrumentation-link-our-messages-to-callback-functions>`
5. :ref:`Message decryption<networked_instrumentation-decrypt-our-messages>`
6. :ref:`Stopping the program and turning off the network connection<networked_instrumentation-turn-off-the-network-and-shutdown-the-program>`

.. _networked_instrumentation-report-the-required-libraries:

Import the Required Libraries
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
To begin with we will import the required libraries:

.. code-block:: python
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros import pp
  from cryptography.fernet import Fernet
  from functools import wraps

On line 1 we see that we will be using the ``pika`` rabbitMq Python library.

Line 3 introduces the ForeignHsm class, which is just an interface around the
spy and trace logs streaming in from another machine.  On line 5 we see we are
calling the Fermet crypto library which we will use for decrypting the messages
coming from the producer.

.. _networked_instrumentation-create-a-class-and-a-drawing-in-its-docstring:

Create a Class and a Drawing in its Docstring
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now we will define a LocalConsumer class which acts as a container of
functionality.  In it, we will draw a picture of our network strategy in its doc
string.

.. code-block:: python
  :emphasize-lines: 8-42
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:

                 |---> LocalConsumer spans this part of pic--->|

                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):
      pass

.. _networked_instrumentation-add-the-rabbitmq-boiler-plat-code-and-ability-to-get-ip:

Add the RabbitMq Boiler Plate Code and Ability to get IP
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now we fill in the boilerplate RabbitMq code required to build two exchanges,
'spy' and 'trace,' both using a 'fanout' strategy.  We create two new queues
that will destroy themselves one the program stops running, identify the name of
these queues and bind the exchange to the queue name.

This boilerplate code needs to know the local IP address.  This information is
obtained from the get_ip static method of the LocalConsumer class.

.. code-block:: python
  :emphasize-lines: 44-68, 70-81
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:

                 |---> LocalConsumer spans this part of pic--->|

                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

  @staticmethod
  def get_ip():
    '''LocalConsumer.get_ip()'''
    ip = '127.0.0.1'
    s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
      # doesn't have to be reachable
      s.connect(('10.255.255.255', 1))
      ip = s.getsockname()[0]
    finally:
      s.close()
    return ip

.. _networked_instrumentation-add-a-shutdown-count-and-a-foreignhsm-object:

Add a Shutdown Count and a ForeignHsm Object
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
We need a way to shut down the program, so we will add a count that we can
compare against.  We will use this count later.

A foreign_hsm will be added, which will consume the spy and trace messages
emitted from the producer on the raspberry pi.  This foreign_hsm object will
have the same ``spy`` and ``trace`` methods of any other miros spy/trace
supported object.  However, if you look inside of the object, there is no event
processor it is just a store of information with an interface that looks like a
statechart object.

.. code-block:: python
  :emphasize-lines: 70-73
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:

                 |---> LocalConsumer spans this part of pic--->|

                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

      # keep a count so we can exit the program
      self.count = 0
      # make a ForeignHsm to track activity on another machine
      self.foreign_hsm = ForeignHsm()

  @staticmethod
  def get_ip():
    '''LocalConsumer.get_ip()'''
    ip = '127.0.0.1'
    s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
      # doesn't have to be reachable
      s.connect(('10.255.255.255', 1))
      ip = s.getsockname()[0]
    finally:
      s.close()
    return ip

.. _networked_instrumentation-link-our-messages-to-callback-functions:

Link our Messages to Callback Functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now we need to link the messages coming from the live spy and live trace on the
raspberry pi to a set of callbacks that do something interesting with this
information, like print it to the terminal of my windows box.

.. code-block:: python
  :emphasize-lines: 76-80, 82-86, 88-91, 93-95
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:

                 |---> LocalConsumer spans this part of pic--->|

                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

      # keep a count so we can exit the program
      self.count = 0
      # make a ForeignHsm to track activity on another machine
      self.foreign_hsm = ForeignHsm()


      def spy_callback(ch, method, properties, body):
        '''create a spy_callback function received messages in the queue'''
        foreign_spy_item = body
        self.foreign_hsm.append_to_spy(foreign_spy_item)
        print(" [x] Spy: {!s}".format(foreign_spy_item))

      def trace_callback(ch, method, properties, body):
        '''create a trace_callback function received messages in the queue'''
        foreign_trace_item = body
        self.foreign_hsm.append_to_trace(foreign_trace_item)
        print(" [x] Trace: {!s}".format(foreign_trace_item))

      # register the spy_callback and trace_callback with a queue
      self.channel.basic_consume(spy_callback,
          queue=spy_queue_name,
          no_ack=True)

      self.channel.basic_consume(trace_callback,
          queue=trace_queue_name,
          no_ack=True)

  @staticmethod
  def get_ip():
    '''LocalConsumer.get_ip()'''
    ip = '127.0.0.1'
    s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
      # doesn't have to be reachable
      s.connect(('10.255.255.255', 1))
      ip = s.getsockname()[0]
    finally:
      s.close()
    return ip

.. _networked_instrumentation-decrypt-our-messages:

Decrypt our Messages
^^^^^^^^^^^^^^^^^^^^
But wait, the messages are encrypted, right?  So if we don't adjust our code, we
will just print a nonsensical set of strings coming from the raspberry pi's
statechart.  We need to decrypt the messages.  To do this, we will decorate the
callback function with a static decrypt method.

Finally, we will need to build an object of the class and run the code:

.. code-block:: python
  :emphasize-lines: 75, 82, 109-118
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:

                 |---> LocalConsumer spans this part of pic--->|

                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

      # keep a count so we can exit the program
      self.count = 0
      # make a ForeignHsm to track activity on another machine
      self.foreign_hsm = ForeignHsm()

      @LocalConsumer.decrypt
      def spy_callback(ch, method, properties, body):
        '''create a spy_callback function received messages in the queue'''
        foreign_spy_item = body
        self.foreign_hsm.append_to_spy(foreign_spy_item)
        print(" [x] Spy: {!s}".format(foreign_spy_item))

      @LocalConsumer.decrypt
      def trace_callback(ch, method, properties, body):
        '''create a trace_callback function received messages in the queue'''
        foreign_trace_item = body
        self.foreign_hsm.append_to_trace(foreign_trace_item)
        print(" [x] Trace: {!s}".format(foreign_trace_item))

      # register the spy_callback and trace_callback with a queue
      self.channel.basic_consume(spy_callback,   queue=spy_queue_name,   no_ack=True)
      self.channel.basic_consume(trace_callback, queue=trace_queue_name, no_ack=True)

    def start(self):
      self.channel.start_consuming()

    @staticmethod
    def get_ip():
      '''LocalConsumer.get_ip()'''
      ip = '127.0.0.1'
      s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      try:
        # doesn't have to be reachable
        s.connect(('10.255.255.255', 1))
        ip = s.getsockname()[0]
      finally:
        s.close()
      return ip

    @staticmethod
    def decrypt(fn):
      @wraps(fn)
      def _decrypt(ch, method, properties, cyphertext):
        '''LocalConsumer.decrypt()'''
        key = b'u3Uc-qAi9iiCv3fkBfRUAKrM1gH8w51-nVU8M8A73Jg='
        f = Fernet(key)
        plain_text = f.decrypt(cyphertext).decode()
        fn(ch, method, properties, plain_text)
      return _decrypt


  if __name__ == "__main__":
    local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')
    local_consumer.start()

.. _networked_instrumentation-turn-off-the-network-and-shutdown-the-program:

Turn off the Network and Shutdown the Program
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So, it's mostly working, but how do we stop it?  When asked about this on stack
overflow the ``pika`` maintainer recommended a timeout callback that can call
the ``stop_consuming`` method of the channel class.  So we will add a callback
that has a timer, references our count and can resubscribe itself if it is too
soon to quit.

.. code-block:: python
  :emphasize-lines: 89-102, 104-105
  :linenos:

  import pika
  import socket
  from miros.foreign import ForeignHsm
  from miros import pp
  from cryptography.fernet import Fernet
  from functools import wraps

  class LocalConsumer():
    '''
    The Local Consumer looks like this:

                 |---> LocalConsumer spans this part of pic--->|

                    +----------------+  +----------------------+
       +-----+   +->| spy exchange   +->| queue (random name)  |
       |     |   |  +----------------+  +------+---------------+
       |  p  +-->|                             |
       |     |   |                             +-> spy_callback
       +-----+   |  +----------------+  +----------------------+
                 +->| trace exchange +->| queue (random name)  |
                    +----------------+  +------+---------------+
                                               |
                                               +-> trace_callback

    ``p`` is the producer (statechart emitting spy/trace information) on
    another machine. (See c_trace_producer.py)

    The spy_callback/trace_callback place decrypted spy/trace strings into the
    foreign_hsm.  This foreign_hsm has the same spy/trace api as a local object
    from a class which is inherited from the HsmWithQueue.

    To build a LocalConsumer:

      local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')

    To start it:

      local_consumer.start()

    '''
    def __init__(self, rabbit_user, rabbit_password):

      # rabbit related
      self.rabbit_user     = rabbit_user
      self.rabbit_password = rabbit_password
      credentials          = pika.PlainCredentials(rabbit_user, rabbit_password)
      parameters           = pika.ConnectionParameters(
                              LocalConsumer.get_ip(),
                              5672,
                              '/',
                              credentials)
      self.connection      = pika.BlockingConnection(parameters=parameters)
      self.channel         = self.connection.channel()
      self.channel.exchange_declare(exchange='spy',   exchange_type='fanout')
      self.channel.exchange_declare(exchange='trace', exchange_type='fanout')

      # create new queues, and ensure they destroy themselves when we disconnect
      # from them
      spy_result   = self.channel.queue_declare(exclusive=True)
      trace_result = self.channel.queue_declare(exclusive=True)

      # queue names are random, so we need to get their names
      spy_queue_name   = spy_result.method.queue
      trace_queue_name = trace_result.method.queue

      # bind the exchanges to each of the queues
      self.channel.queue_bind(exchange='spy', queue=spy_queue_name)
      self.channel.queue_bind(exchange='trace', queue=trace_queue_name)

      # keep a count so we can exit the program
      self.count = 0
      # make a ForeignHsm to track activity on another machine
      self.foreign_hsm = ForeignHsm()

      @LocalConsumer.decrypt
      def spy_callback(ch, method, properties, body):
        '''create a spy_callback function received messages in the queue'''
        foreign_spy_item = body
        self.foreign_hsm.append_to_spy(foreign_spy_item)
        print(" [x] Spy: {!s}".format(foreign_spy_item))

      @LocalConsumer.decrypt
      def trace_callback(ch, method, properties, body):
        '''create a trace_callback function received messages in the queue'''
        foreign_trace_item = body
        self.foreign_hsm.append_to_trace(foreign_trace_item)
        print(" [x] Trace: {!s}".format(foreign_trace_item))

      def timeout_callback():
        '''callback for outputting the foreign trace and exiting the program'''
        spy = self.foreign_hsm.spy()
        if len(spy) is not 0:
          pp(self.foreign_hsm.spy())
          print(self.foreign_hsm.trace())
        self.count += 1
        # stop processing or reconnect this callback to a timer
        if self.count >= 30:
          self.channel.stop_consuming()
        else:
          self.connection.add_timeout(deadline=1, callback_method=timeout_callback)
          self.foreign_hsm.clear_spy()
          self.foreign_hsm.clear_trace()

      # Add the timeout callback
      self.connection.add_timeout(deadline=10, callback_method=timeout_callback)

      # register the spy_callback and trace_callback with a queue
      self.channel.basic_consume(spy_callback,   queue=spy_queue_name,   no_ack=True)
      self.channel.basic_consume(trace_callback, queue=trace_queue_name, no_ack=True)

    def start(self):
      self.channel.start_consuming()

    @staticmethod
    def get_ip():
      '''LocalConsumer.get_ip()'''
      ip = '127.0.0.1'
      s  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      try:
        # doesn't have to be reachable
        s.connect(('10.255.255.255', 1))
        ip = s.getsockname()[0]
      finally:
        s.close()
      return ip

    @staticmethod
    def decrypt(fn):
      @wraps(fn)
      def _decrypt(ch, method, properties, cyphertext):
        '''LocalConsumer.decrypt()'''
        key = b'u3Uc-qAi9iiCv3fkBfRUAKrM1gH8w51-nVU8M8A73Jg='
        f = Fernet(key)
        plain_text = f.decrypt(cyphertext).decode()
        fn(ch, method, properties, plain_text)
      return _decrypt


  if __name__ == "__main__":
    local_consumer = LocalConsumer(rabbit_user='bob', rabbit_password='dobbs')
    local_consumer.start()

Closing a program like this seems somewhat clumsy.  In the future, we will call
the ``stop_consuming`` method from within a statechart based on a statechart.

So there you have it, a full consumer.  Let's run it and the producer and see
what happens.

The consumer outputs:

.. code-block:: guess
  :linenos:

   [x] Trace: [2018-01-10 18:23:35.647035] [rabbit_producer_192.168.1.72] e->start_at() top->c1
   [x] Spy: START
   [x] Spy: SEARCH_FOR_SUPER_SIGNAL:producer_outer
   [x] Spy: ENTRY_SIGNAL:producer_outer
   [x] Spy: INIT_SIGNAL:producer_outer
   [x] Spy: SEARCH_FOR_SUPER_SIGNAL:c1
   [x] Spy: ENTRY_SIGNAL:c1
   [x] Spy: INIT_SIGNAL:c1
   [x] Spy: <- Queued:(0) Deferred:(0)
   [x] Trace: [2018-01-10 18:23:35.932470] [rabbit_producer_192.168.1.72] e->B() c1->c1
   [x] Spy: B:c1
   [x] Spy: B:producer_outer
   [x] Spy: EXIT_SIGNAL:c1
   [x] Spy: EXIT_SIGNAL:producer_outer
   [x] Spy: ENTRY_SIGNAL:producer_outer
   [x] Spy: INIT_SIGNAL:producer_outer
   [x] Spy: SEARCH_FOR_SUPER_SIGNAL:c1
   [x] Spy: ENTRY_SIGNAL:c1
   [x] Spy: INIT_SIGNAL:c1
   [x] Spy: <- Queued:(0) Deferred:(0)
  ['START',
   'SEARCH_FOR_SUPER_SIGNAL:producer_outer',
   'ENTRY_SIGNAL:producer_outer',
   'INIT_SIGNAL:producer_outer',
   'SEARCH_FOR_SUPER_SIGNAL:c1',
   'ENTRY_SIGNAL:c1',
   'INIT_SIGNAL:c1',
   '<- Queued:(0) Deferred:(0)',
   'B:c1',
   'B:producer_outer',
   'EXIT_SIGNAL:c1',
   'EXIT_SIGNAL:producer_outer',
   'ENTRY_SIGNAL:producer_outer',
   'INIT_SIGNAL:producer_outer',
   'SEARCH_FOR_SUPER_SIGNAL:c1',
   'ENTRY_SIGNAL:c1',
   'INIT_SIGNAL:c1',
   '<- Queued:(0) Deferred:(0)']
  [2018-01-10 18:23:35.647035] [rabbit_producer_192.168.1.72] e->start_at() top->c1
  [2018-01-10 18:23:35.932470] [rabbit_producer_192.168.1.72] e->B() c1->c1

So we see that the decryption worked and the live spy and traced messages were
being emitted onto the screen as they were received from the network.  We also
see that the foreign_hsm object's ``spy`` and ``trace`` methods output
instrumentation results as if they were coming from a real statechart running on
this machine.

To see the full consumer code, reference this `c_trace_consumer`_.

We have succeeded in aggregating spy and trace messages generated on one machine
within another.

:ref:`back to examples <examples>`

.. _c_trace_consumer: https://github.com/aleph2c/miros/blob/master/examples/c_trace_consumer.py
.. _c_trace_producer: https://github.com/aleph2c/miros/blob/master/examples/c_trace_producer.py
.. _simple pub-sub: https://www.rabbitmq.com/tutorials/tutorial-three-python.html
.. _networked pub-sub send: https://github.com/aleph2c/miros/blob/master/experiment/rabbit/c_emit_log_fanout.py
.. _networked pub-sub receive: https://github.com/aleph2c/miros/blob/master/experiment/rabbit/c_receive_logs_fanout.py
